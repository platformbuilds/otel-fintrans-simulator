package main

import (
	"fmt"
	"math/rand"
	"time"

	"os"

	"gopkg.in/yaml.v3"
)

// TelemetryConfig holds names and attributes for telemetry generated by the simulator
type TelemetryConfig struct {
	ServiceNames struct {
		APIGateway      string `yaml:"api_gateway"`
		TPS             string `yaml:"tps"`
		CassandraClient string `yaml:"cassandra_client"`
		KeyDBClient     string `yaml:"keydb_client"`
		KafkaProducer   string `yaml:"kafka_producer"`
		KafkaConsumer   string `yaml:"kafka_consumer"`
	} `yaml:"service_names"`

	MetricNames struct {
		TransactionsTotal      string            `yaml:"transactions_total"`
		TransactionsFailed     string            `yaml:"transactions_failed_total"`
		DBOpsTotal             string            `yaml:"db_ops_total"`
		KafkaProduceTotal      string            `yaml:"kafka_produce_total"`
		KafkaConsumeTotal      string            `yaml:"kafka_consume_total"`
		TransactionLatency     string            `yaml:"transaction_latency_seconds"`
		DBLatency              string            `yaml:"db_latency_seconds"`
		TransactionAmountSum   string            `yaml:"transaction_amount_paisa_sum"`
		TransactionAmountCount string            `yaml:"transaction_amount_paisa_count"`
		Additional             map[string]string `yaml:"additional,omitempty"`
	} `yaml:"metric_names"`

	// Outputs controls where telemetry is shipped. Supported values: "otlp", "stdout".
	// Multiple outputs may be specified, e.g. ["otlp","stdout"]
	Outputs []string `yaml:"outputs,omitempty"`
	// Endpoint for OTLP exporter. Example: "http://localhost:4317"
	Endpoint string `yaml:"endpoint,omitempty"`
	// Whether to use insecure OTLP connection (no TLS). Default: true
	Insecure bool `yaml:"insecure,omitempty"`
	// If true and TLS is used, skip TLS certificate verification (InsecureSkipVerify).
	SkipTLSVerify bool `yaml:"skip_tls_verify,omitempty"`

	// Labels contains sets of values the simulator will use when emitting
	// attributes (labels) on metrics and traces. Keep cardinality small.
	Labels struct {
		OrgIds           []string `yaml:"org_ids,omitempty"`
		OrgNames         []string `yaml:"org_names,omitempty"`
		TransactionTypes []string `yaml:"transaction_types,omitempty"`
	} `yaml:"labels,omitempty"`

	// DynamicMetrics allows declaring new metrics that will be created at startup
	DynamicMetrics []DynamicMetricConfig `yaml:"dynamic_metrics,omitempty"`
}

// DynamicMetricConfig describes a metric that can be created at runtime.
type DynamicMetricConfig struct {
	Name        string    `yaml:"name"`
	Type        string    `yaml:"type"`     // counter | gauge | histogram
	DataType    string    `yaml:"dataType"` // float | int
	Description string    `yaml:"description,omitempty"`
	Buckets     []float64 `yaml:"buckets,omitempty"` // for histograms
}

// Burst describes a temporary window where failure probability is increased.
type Burst struct {
	// Start relative to simulation start: can be duration like "30s" or an absolute RFC3339 time
	Start string `yaml:"start"`
	// Duration of the burst: e.g. "1m"
	Duration string `yaml:"duration"`
	// Multiplier applied to base failure probability (e.g., 3.0 -> 3x failure rate)
	Multiplier float64 `yaml:"multiplier"`
}

// FailureConfig contains options for the failure behavior
type FailureConfig struct {
	Mode   string  `yaml:"mode"` // "random" or "bursty" or "scheduled"
	Rate   float64 `yaml:"rate"` // base probability 0..1
	Seed   *int64  `yaml:"seed,omitempty"`
	Bursts []Burst `yaml:"bursts,omitempty"`
	// Scenarios define more complex, correlated failure/signal injections.
	// Each scenario has a start/duration and a list of effects. Effects target
	// simulator-level dimensions (db_latency, jvm_gc_pressure, transaction_failures, etc.)
	// and can be applied as 'scale', 'add', 'set' or 'ramp'. See README/usage for examples.
	Scenarios []Scenario `yaml:"scenarios,omitempty"`
}

// Scenario defines a multi-metric, correlated injection window.
type Scenario struct {
	Name     string `yaml:"name"`
	Start    string `yaml:"start"`    // relative duration (e.g. "10s") or absolute RFC3339
	Duration string `yaml:"duration"` // e.g. "30s"
	// Labels narrow the scope for this scenario (e.g., OrgId values this scenario should affect)
	Labels map[string][]string `yaml:"labels,omitempty"`
	// Effects describe what to change and how (metric name, operation, value)
	Effects []Effect `yaml:"effects,omitempty"`
}

// Effect describes a single modification to a named effect target.
type Effect struct {
	Metric string  `yaml:"metric"` // e.g. "db_latency", "transaction_failures", "jvm_gc_pressure"
	Op     string  `yaml:"op"`     // "scale", "add", "set", "ramp"
	Value  float64 `yaml:"value"`  // scale factor or absolute value
	// Optional per-tick step for ramps (applies each background tick) - if 0, immediate
	Step float64 `yaml:"step,omitempty"`
}

// SimulatorConfig is the top-level configuration for the simulator
type SimulatorConfig struct {
	Telemetry TelemetryConfig `yaml:"telemetry"`
	Failure   FailureConfig   `yaml:"failure"`
}

// LoadConfig loads a config from a YAML file path.
// If path is empty, this returns the zero config (defaults are applied by caller).
func LoadConfig(path string) (*SimulatorConfig, error) {
	if path == "" {
		return &SimulatorConfig{}, nil
	}

	bytes, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read config: %w", err)
	}

	var cfg SimulatorConfig
	if err := yaml.Unmarshal(bytes, &cfg); err != nil {
		return nil, fmt.Errorf("unmarshal config: %w", err)
	}

	return &cfg, nil
}

// failureScheduler decides if a given transaction should fail depending on time and burst schedule
type failureScheduler struct {
	cfg    FailureConfig
	start  time.Time
	rng    *rand.Rand
	bursts []struct {
		start time.Time
		end   time.Time
		mult  float64
	}
}

// newFailureScheduler builds a scheduler. simStart is the simulation start time used to resolve relative starts.
func newFailureScheduler(cfg FailureConfig, simStart time.Time) (*failureScheduler, error) {
	fs := &failureScheduler{cfg: cfg, start: simStart}

	// seed rng if provided
	if cfg.Seed != nil {
		fs.rng = rand.New(rand.NewSource(*cfg.Seed))
	} else {
		fs.rng = rand.New(rand.NewSource(time.Now().UnixNano()))
	}

	for _, b := range cfg.Bursts {
		// parse start: support duration (relative) or RFC3339 absolute
		var s time.Time
		if d, err := time.ParseDuration(b.Start); err == nil {
			s = simStart.Add(d)
		} else if t, err := time.Parse(time.RFC3339, b.Start); err == nil {
			s = t
		} else {
			return nil, fmt.Errorf("invalid burst start: %s", b.Start)
		}

		dur, err := time.ParseDuration(b.Duration)
		if err != nil {
			return nil, fmt.Errorf("invalid burst duration: %s", b.Duration)
		}

		fs.bursts = append(fs.bursts, struct {
			start, end time.Time
			mult       float64
		}{start: s, end: s.Add(dur), mult: b.Multiplier})
	}

	return fs, nil
}

// ShouldFail returns true if a transaction at the given time should fail.
// The algorithm uses the configured mode and burst schedule.
func (fs *failureScheduler) ShouldFail(at time.Time) bool {
	base := fs.cfg.Rate
	if base <= 0 {
		return false
	}

	// check bursts
	multiplier := 1.0
	for _, b := range fs.bursts {
		if !at.Before(b.start) && at.Before(b.end) {
			if b.mult > 0 {
				multiplier = b.mult
			}
			break
		}
	}

	var prob float64
	switch fs.cfg.Mode {
	case "bursty":
		// base rate is scaled by burst multiplier
		prob = base * multiplier
	case "scheduled":
		// treat similar to bursty but base works only when in bursts
		if multiplier > 1.0 {
			prob = base * multiplier
		} else {
			prob = 0
		}
	default:
		// random
		prob = base
	}

	return fs.rng.Float64() < prob
}

// ProbabilityAt returns the computed failure probability at the given time
// without sampling randomness. This is useful for deterministic tests.
func (fs *failureScheduler) ProbabilityAt(at time.Time) float64 {
	base := fs.cfg.Rate
	if base <= 0 {
		return 0
	}

	multiplier := 1.0
	for _, b := range fs.bursts {
		if !at.Before(b.start) && at.Before(b.end) {
			if b.mult > 0 {
				multiplier = b.mult
			}
			break
		}
	}

	switch fs.cfg.Mode {
	case "bursty":
		return base * multiplier
	case "scheduled":
		if multiplier > 1.0 {
			return base * multiplier
		}
		return 0
	default:
		return base
	}
}
