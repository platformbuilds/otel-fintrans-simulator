package main

import (
	"fmt"
	"math/rand"
	"time"

	"io/ioutil"

	"gopkg.in/yaml.v3"
)

// TelemetryConfig holds names and attributes for telemetry generated by the simulator
type TelemetryConfig struct {
	ServiceNames struct {
		APIGateway      string `yaml:"api_gateway"`
		TPS             string `yaml:"tps"`
		CassandraClient string `yaml:"cassandra_client"`
		KeyDBClient     string `yaml:"keydb_client"`
		KafkaProducer   string `yaml:"kafka_producer"`
		KafkaConsumer   string `yaml:"kafka_consumer"`
	} `yaml:"service_names"`

	MetricNames struct {
		TransactionsTotal      string `yaml:"transactions_total"`
		TransactionsFailed     string `yaml:"transactions_failed_total"`
		DBOpsTotal             string `yaml:"db_ops_total"`
		KafkaProduceTotal      string `yaml:"kafka_produce_total"`
		KafkaConsumeTotal      string `yaml:"kafka_consume_total"`
		TransactionLatency     string `yaml:"transaction_latency_seconds"`
		DBLatency              string `yaml:"db_latency_seconds"`
		TransactionAmountSum   string `yaml:"transaction_amount_paisa_sum"`
		TransactionAmountCount string `yaml:"transaction_amount_paisa_count"`
	} `yaml:"metric_names"`

	// Outputs controls where telemetry is shipped. Supported values: "otlp", "stdout".
	// Multiple outputs may be specified, e.g. ["otlp","stdout"]
	Outputs []string `yaml:"outputs,omitempty"`
}

// Burst describes a temporary window where failure probability is increased.
type Burst struct {
	// Start relative to simulation start: can be duration like "30s" or an absolute RFC3339 time
	Start string `yaml:"start"`
	// Duration of the burst: e.g. "1m"
	Duration string `yaml:"duration"`
	// Multiplier applied to base failure probability (e.g., 3.0 -> 3x failure rate)
	Multiplier float64 `yaml:"multiplier"`
}

// FailureConfig contains options for the failure behavior
type FailureConfig struct {
	Mode   string  `yaml:"mode"` // "random" or "bursty" or "scheduled"
	Rate   float64 `yaml:"rate"` // base probability 0..1
	Seed   *int64  `yaml:"seed,omitempty"`
	Bursts []Burst `yaml:"bursts,omitempty"`
}

// SimulatorConfig is the top-level configuration for the simulator
type SimulatorConfig struct {
	Telemetry TelemetryConfig `yaml:"telemetry"`
	Failure   FailureConfig   `yaml:"failure"`
}

// LoadConfig loads a config from a YAML file path.
// If path is empty, this returns the zero config (defaults are applied by caller).
func LoadConfig(path string) (*SimulatorConfig, error) {
	if path == "" {
		return &SimulatorConfig{}, nil
	}

	bytes, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read config: %w", err)
	}

	var cfg SimulatorConfig
	if err := yaml.Unmarshal(bytes, &cfg); err != nil {
		return nil, fmt.Errorf("unmarshal config: %w", err)
	}

	return &cfg, nil
}

// failureScheduler decides if a given transaction should fail depending on time and burst schedule
type failureScheduler struct {
	cfg    FailureConfig
	start  time.Time
	rng    *rand.Rand
	bursts []struct {
		start time.Time
		end   time.Time
		mult  float64
	}
}

// newFailureScheduler builds a scheduler. simStart is the simulation start time used to resolve relative starts.
func newFailureScheduler(cfg FailureConfig, simStart time.Time) (*failureScheduler, error) {
	fs := &failureScheduler{cfg: cfg, start: simStart}

	// seed rng if provided
	if cfg.Seed != nil {
		fs.rng = rand.New(rand.NewSource(*cfg.Seed))
	} else {
		fs.rng = rand.New(rand.NewSource(time.Now().UnixNano()))
	}

	for _, b := range cfg.Bursts {
		// parse start: support duration (relative) or RFC3339 absolute
		var s time.Time
		if d, err := time.ParseDuration(b.Start); err == nil {
			s = simStart.Add(d)
		} else if t, err := time.Parse(time.RFC3339, b.Start); err == nil {
			s = t
		} else {
			return nil, fmt.Errorf("invalid burst start: %s", b.Start)
		}

		dur, err := time.ParseDuration(b.Duration)
		if err != nil {
			return nil, fmt.Errorf("invalid burst duration: %s", b.Duration)
		}

		fs.bursts = append(fs.bursts, struct {
			start, end time.Time
			mult       float64
		}{start: s, end: s.Add(dur), mult: b.Multiplier})
	}

	return fs, nil
}

// ShouldFail returns true if a transaction at the given time should fail.
// The algorithm uses the configured mode and burst schedule.
func (fs *failureScheduler) ShouldFail(at time.Time) bool {
	base := fs.cfg.Rate
	if base <= 0 {
		return false
	}

	// check bursts
	multiplier := 1.0
	for _, b := range fs.bursts {
		if !at.Before(b.start) && at.Before(b.end) {
			if b.mult > 0 {
				multiplier = b.mult
			}
			break
		}
	}

	var prob float64
	switch fs.cfg.Mode {
	case "bursty":
		// base rate is scaled by burst multiplier
		prob = base * multiplier
	case "scheduled":
		// treat similar to bursty but base works only when in bursts
		if multiplier > 1.0 {
			prob = base * multiplier
		} else {
			prob = 0
		}
	default:
		// random
		prob = base
	}

	return fs.rng.Float64() < prob
}

// ProbabilityAt returns the computed failure probability at the given time
// without sampling randomness. This is useful for deterministic tests.
func (fs *failureScheduler) ProbabilityAt(at time.Time) float64 {
	base := fs.cfg.Rate
	if base <= 0 {
		return 0
	}

	multiplier := 1.0
	for _, b := range fs.bursts {
		if !at.Before(b.start) && at.Before(b.end) {
			if b.mult > 0 {
				multiplier = b.mult
			}
			break
		}
	}

	switch fs.cfg.Mode {
	case "bursty":
		return base * multiplier
	case "scheduled":
		if multiplier > 1.0 {
			return base * multiplier
		}
		return 0
	default:
		return base
	}
}
